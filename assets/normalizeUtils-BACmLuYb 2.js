import{aI as O,co as T,U as C,f as D,I as Q,a7 as W,cQ as _,d as F,dg as z,t as B,v as U,ai as E,s as G}from"./index-BdXiYUWp.js";import{r as L,i as N,o as P,s as X}from"./normalizeUtilsCommon-DnAXcLGn.js";import{f as H}from"./utils-Bh8BC7JY.js";import{r as K,o as V}from"./utils-BllU-TlI.js";async function Y(e,s,f,n){const t=H(e),c=s[0].spatialReference,l={...n,responseType:"json",query:{...t.query,f:"json",sr:T(c),target:JSON.stringify({geometryType:O(s[0]),geometries:s}),cutter:JSON.stringify(f)}},o=await C(t.path+"/cut",l),{cutIndexes:a,geometries:m=[]}=o.data;return{cutIndexes:a,geometries:m.map(h=>{const x=D(h);return x.spatialReference=c,x})}}async function Z(e,s,f){const n=typeof e=="string"?Q(e):e,t=s[0].spatialReference,c=O(s[0]),l={...f,query:{...n.query,f:"json",sr:T(t),geometries:JSON.stringify(K(s))}},{data:o}=await C(n.path+"/simplify",l);return V(o.geometries,c,t)}const k=()=>B.getLogger("esri.geometry.support.normalizeUtils");function ee(e){return e.type==="polygon"}function te(e){return e[0].type==="polygon"}function se(e){return e[0].type==="polyline"}function ne(e,s){if(!(e instanceof F||e instanceof U)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw k().error(t),new G(t)}const f=P(e),n=[];for(const t of f){const c=[];n.push(c),c.push([t[0][0],t[0][1]]);for(let l=0;l<t.length-1;l++){const o=t[l][0],a=t[l][1],m=t[l+1][0],h=t[l+1][1],x=Math.sqrt((m-o)*(m-o)+(h-a)*(h-a)),u=(h-a)/x,d=(m-o)/x,p=x/s;if(p>1){for(let b=1;b<=p-1;b++){const j=b*s,r=d*j+o,i=u*j+a;c.push([r,i])}const w=(x+Math.floor(p-1)*s)/2,I=d*w+o,S=u*w+a;c.push([I,S])}c.push([m,h])}}return ee(e)?new U({rings:n,spatialReference:e.spatialReference}):new F({paths:n,spatialReference:e.spatialReference})}function v(e,s,f){if(s){const n=ne(e,1e6);e=E(n,!0)}return f&&(e=X(e,f)),e}function J(e,s,f){if(Array.isArray(e)){const n=e[0];if(n>s){const t=N(n,s);e[0]=n+t*(-2*s)}else if(n<f){const t=N(n,f);e[0]=n+t*(-2*f)}}else{const n=e.x;if(n>s){const t=N(n,s);e=e.clone().offset(t*(-2*s),0)}else if(n<f){const t=N(n,f);e=e.clone().offset(t*(-2*f),0)}}return e}function oe(e,s){let f=-1;for(let n=0;n<s.cutIndexes.length;n++){const t=s.cutIndexes[n],c=s.geometries[n],l=P(c);for(let o=0;o<l.length;o++){const a=l[o];a.some(m=>{if(m[0]<180)return!0;{let h=0;for(let u=0;u<a.length;u++){const d=a[u][0];h=d>h?d:h}h=Number(h.toFixed(9));const x=-360*N(h,180);for(let u=0;u<a.length;u++){const d=c.getPoint(o,u);c.setPoint(o,u,d.clone().offset(x,0))}return!0}})}if(t===f){if(te(e))for(const o of P(c))e[t]=e[t].addRing(o);else if(se(e))for(const o of P(c))e[t]=e[t].addPath(o)}else f=t,e[t]=c}return e}async function re(e,s,f){if(!Array.isArray(e))return re([e],s);s&&typeof s!="string"&&k().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:(s==null?void 0:s.url)??W.geometryServiceUrl;let t,c,l,o,a,m,h,x,u=0;const d=[],p=[];for(const r of e)if(r!=null)if(t||(t=r.spatialReference,c=_(t),l=t.isWebMercator,m=l?102100:4326,o=L[m].maxX,a=L[m].minX,h=L[m].plus180Line,x=L[m].minus180Line),c)if(r.type==="mesh")p.push(r);else if(r.type==="point")p.push(J(r.clone(),o,a));else if(r.type==="multipoint"){const i=r.clone();i.points=i.points.map(y=>J(y,o,a)),p.push(i)}else if(r.type==="extent"){const i=r.clone()._normalize(!1,!1,c);p.push(i.rings?new U(i):i)}else if(r.extent){const i=r.extent,y=N(i.xmin,a)*(2*o);let $=y===0?r.clone():X(r.clone(),y);i.offset(y,0);let{xmin:R,xmax:g}=i;R=Number(R.toFixed(9)),g=Number(g.toFixed(9)),i.intersects(h)&&g!==o?(u=g>u?g:u,$=v($,l),d.push($),p.push("cut")):i.intersects(x)&&R!==a?(u=g*(2*o)>u?g*(2*o):u,$=v($,l,360),d.push($),p.push("cut")):p.push($)}else p.push(r.clone());else p.push(r);else p.push(r);let w=N(u,o),I=-90;const S=w,b=new F;for(;w>0;){const r=360*w-180;b.addPath([[r,I],[r,-1*I]]),I*=-1,w--}if(d.length>0&&S>0){const r=oe(d,await Y(n,d,b,f)),i=[],y=[];for(let g=0;g<p.length;g++){const M=p[g];if(M!=="cut")y.push(M);else{const A=r.shift(),q=e[g];q!=null&&q.type==="polygon"&&q.rings&&q.rings.length>1&&A.rings.length>=q.rings.length?(i.push(A),y.push("simplify")):y.push(l?z(A):A)}}if(!i.length)return y;const $=await Z(n,i,f),R=[];for(let g=0;g<y.length;g++){const M=y[g];M!=="simplify"?R.push(M):R.push(l?z($.shift()):$.shift())}return R}const j=[];for(let r=0;r<p.length;r++){const i=p[r];if(i!=="cut")j.push(i);else{const y=d.shift();j.push(l===!0?z(y):y)}}return j}export{re as R};
