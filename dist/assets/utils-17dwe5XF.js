import{bq as C,cM as G,cN as O,cx as z,cO as P,g as V,cP as A,cQ as D,j as L,cK as R}from"./index-DMwY2Yeh.js";import{r as E}from"./TimeExtent-D_QVyVxF.js";import{j as U,u as Y,l as _}from"./heatmapUtils-BzMZhmln.js";import"./Basemap-BELjkky8.js";import"./mat4f32-DcsiF_Rp.js";import"./mat4-DsYZliz4.js";import{m as T,B as q}from"./utils-ClehEbQ3.js";function B(e){return C(e)||G(e)||O(e)}let u=null;const K=/^(?<hh>([0-1][0-9])|([2][0-3])):(?<mm>[0-5][0-9])(:(?<ss>[0-5][0-9]))?([.](?<ms>\d+))?$/;function Q(e,t,i){return e.x<0?e.x+=t:e.x>i&&(e.x-=t),e}function te(e,t,i,a){const r=A(i)?D(i):null,c=r?Math.round((r.valid[1]-r.valid[0])/t.scale[0]):null;return e.map(s=>{const o=new L(s.geometry);return U(t,o,o),s.geometry=r?Q(o,c??0,a[0]):o,s})}function ne(e,t=18,i,a,r){const c=new Float64Array(a*r);t=Math.round(R(t));let s=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY;const y=Y(i);for(const{geometry:p,attributes:N}of e){const{x:$,y:m}=p,I=Math.max(0,$-t),M=Math.max(0,m-t),F=Math.min(r,m+t),b=Math.min(a,$+t),h=+y(N);for(let f=M;f<F;f++)for(let d=I;d<b;d++){const g=f*a+d,w=_(d-$,f-m,t)*h,l=c[g]+=w;s=Math.min(s,l),o=Math.max(o,l)}}return{min:s,max:o}}function S(e){const t=K.exec(e);if(!t)return null;const{hh:i,mm:a,ss:r,ms:c}=t.groups;return Number(i)*E.hours+Number(a)*E.minutes+Number(r)*E.seconds+Number(c||0)}async function re(e,t,i=!0){if(!t)return[];const{field:a,field2:r,field3:c,fieldDelimiter:s,fieldInfos:o,timeZone:y}=e,p=a&&(o==null?void 0:o.find(l=>l.name.toLowerCase()===a.toLowerCase())),N=!!p&&z(p),$=!!p&&B(p),m=e.valueExpression,I=e.normalizationType,M=e.normalizationField,F=e.normalizationTotal,b=[],h=e.viewInfoParams;let f=null,d=null;if(m){if(!u){const{arcadeUtils:l}=await P();u=l}u.hasGeometryOperations(m)&&await u.enableGeometryOperations(),f=u.createFunction(m),d=h?u.getViewInfo({viewingMode:h.viewingMode,scale:h.scale,spatialReference:new V(h.spatialReference)}):null}const g=e.fieldInfos,w=!(t[0]&&"declaredClass"in t[0]&&t[0].declaredClass==="esri.Graphic")&&g?{fields:g}:null;return t.forEach(l=>{const x=l.attributes;let n;if(m){const v=w?{...l,layer:w}:l,j=u.createExecContext(v,d,y);n=u.executeFunction(f,j)}else x&&(n=x[a],r?(n=`${T(n)}${s}${T(x[r])}`,c&&(n=`${n}${s}${T(x[c])}`)):typeof n=="string"&&i&&($?n=n?new Date(n).getTime():null:N&&(n=n?S(n):null)));if(I&&typeof n=="number"&&isFinite(n)){const v=x&&parseFloat(x[M]);n=q(n,I,v,F)}b.push(n)}),b}export{S as I,re as b,ne as w,te as x};
